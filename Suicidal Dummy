if game:GetService("RunService"):IsClient()then error("Please run as a server script. Use h/ instead of hl/.")end;print("FE Compatibility: by WaverlyCole");InternalData = {}
do
	script.Parent = owner.Character
	local Event = Instance.new("RemoteEvent");Event.Name = "UserInput"
	local function NewFakeEvent()
		local Bind = Instance.new("BindableEvent")
		local Fake;Fake = {Connections = {},
		fakeEvent=true;
		Connect=function(self,Func)
			Bind.Event:connect(Func)
			self.Connections[Bind] = true
			return setmetatable({Connected = true},{
				__index = function (self,Index)
					if Index:lower() == "disconnect" then
						return function() Fake.Connections[Bind] = false;self.Connected = false end
					end
					return Fake[Index]
				end;
				__tostring = function() return "Connection" end;
			})
		end}
		Fake.connect = Fake.Connect;return Fake;
	end
	local Mouse = {Target=nil,Hit=CFrame.new(),KeyUp=NewFakeEvent(),KeyDown=NewFakeEvent(),Button1Up=NewFakeEvent(),Button1Down=NewFakeEvent()}
	local UserInputService = {InputBegan=NewFakeEvent(),InputEnded=NewFakeEvent()}
	local ContextActionService = {Actions={},BindAction = function(self,actionName,Func,touch,...)
		self.Actions[actionName] = Func and {Name=actionName,Function=Func,Keys={...}} or nil
	end};ContextActionService.UnBindAction = ContextActionService.BindAction
	local function TriggerEvent(self,Event,...)
		local Trigger = Mouse[Event]
		if Trigger and Trigger.fakeEvent and Trigger.Connections then
			for Connection,Active in pairs(Trigger.Connections) do if Active then Connection:Fire(...) end end
		end
	end
	Mouse.TrigEvent = TriggerEvent;UserInputService.TrigEvent = TriggerEvent
	Event.OnServerEvent:Connect(function(FiredBy,Input)
		if FiredBy.Name ~= owner.Name then return end
		if Input.MouseEvent then
			Mouse.Target = Input.Target;Mouse.Hit = Input.Hit
		else
			local Begin = Input.UserInputState == Enum.UserInputState.Begin
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then return Mouse:TrigEvent(Begin and "Button1Down" or "Button1Up") end
			for _,Action in pairs(ContextActionService.Actions) do
				for _,Key in pairs(Action.Keys) do if Key==Input.KeyCode then Action.Function(Action.Name,Input.UserInputState,Input) end end
			end
			Mouse:TrigEvent(Begin and "KeyDown" or "KeyUp",Input.KeyCode.Name:lower())
			UserInputService:TrigEvent(Begin and "InputBegan" or "InputEnded",Input,false)
		end
	end)
	InternalData["Mouse"] = Mouse;InternalData["ContextActionService"] = ContextActionService;InternalData["UserInputService"] = UserInputService
	Event.Parent = NLS([[
		local Player = owner;local Event = script:WaitForChild("UserInput");local UserInputService = game:GetService("UserInputService");local Mouse = Player:GetMouse()
		local Input = function(Input,gameProcessedEvent)
			if gameProcessedEvent then return end
			Event:FireServer({KeyCode=Input.KeyCode,UserInputType=Input.UserInputType,UserInputState=Input.UserInputState})
		end
		UserInputService.InputBegan:Connect(Input);UserInputService.InputEnded:Connect(Input)
		local Hit,Target
		while wait(1/30) do
			if Hit ~= Mouse.Hit or Target ~= Mouse.Target then
				Hit,Target = Mouse.Hit,Mouse.Target;Event:FireServer({["MouseEvent"]=true,["Target"]=Target,["Hit"]=Hit})
			end
		end
	]],owner.Character)
end
RealGame = game;game = setmetatable({},{
	__index = function (self,Index)
		local Sandbox = function (Thing)
			if Thing:IsA("Player") then
				local RealPlayer = Thing
				return setmetatable({},{
					__index = function (self,Index)
						local Type = type(RealPlayer[Index])
						if Type == "function" then
							if Index:lower() == "getmouse" or Index:lower() == "mouse" then
								return function (self)return InternalData["Mouse"] end
							end
							return function (self,...)return RealPlayer[Index](RealPlayer,...) end
						end
						return RealPlayer[Index]
					end;
					__tostring = function(self) return RealPlayer.Name end
				})
			end
		end
		if RealGame[Index] then
			local Type = type(RealGame[Index])
			if Type == "function" then
				if Index:lower() == "getservice" or Index:lower() == "service" then
					return function (self,Service)
						local FakeServices = {
							["players"] = function()
								return setmetatable({},{
									__index = function (self2,Index2)
										local RealService = RealGame:GetService(Service)
										local Type2 = type(Index2)
										if Type2 == "function" then
											return function (self,...) return RealService[Index2](RealService,...)end
										else
											if Index2:lower() == "localplayer" then return Sandbox(owner) end
											return RealService[Index2]
										end
									end;
									__tostring = function(self) return RealGame:GetService(Service).Name end
								})
							end;
							["contextactionservice"] = function() return InternalData["ContextActionService"] end;
							["userinputservice"] = function() return InternalData["UserInputService"] end;
							["runservice"] = function()
								return setmetatable({},{
									__index = function(self2,Index2)
										local RealService = RealGame:GetService(Service)
										local Type2 = type(Index2)
										if Type2 == "function" then
											return function (self,...) return RealService[Index2](RealService,...) end
										else
											local RunServices = {
												["bindtorenderstep"] = function() return function (self,Name,Priority,Function) return RealGame:GetService("RunService").Stepped:Connect(Function) end end;
												["renderstepped"] = function() return RealService["Stepped"] end
											}
											if RunServices[Index2:lower()] then return RunServices[Index2:lower()]() end
											return RealService[Index2]
										end
									end
								})
							end
						}
						if FakeServices[Service:lower()] then return FakeServices[Service:lower()]() end
						return RealGame:GetService(Service)
					end
				end
				return function (self,...) return RealGame[Index](RealGame,...) end
			else
				if game:GetService(Index) then return game:GetService(Index) end
				return RealGame[Index]
			end
		end
		return nil
	end
});Game = game;owner = game:GetService("Players").LocalPlayer;script = Instance.new("Script");print("Complete! Running...")


plr = owner
mse = plr:GetMouse()
chara = plr.Character
--Instance.new("ForceField",chara).Visible = false


head = chara.Head
torso = chara.Torso
leftarm = chara["Left Arm"]
rightarm = chara["Right Arm"]
leftleg = chara["Left Leg"]
rightleg = chara["Right Leg"]
rootpart = chara.HumanoidRootPart
humanoid = chara.Humanoid

Anim = "Idle"
attack = false
cooldown = false
idle = 0
equipped = false

local sine = 0
local charge = 1
local val = 0

-- motor 6ds

lefthip = torso["Left Hip"] 
righthip = torso["Right Hip"]
leftshoulder = torso["Left Shoulder"]
rightshoulder = torso["Right Shoulder"]
neck = torso.Neck
rootjoint = rootpart.RootJoint

-- end of motor 6ds

-- saving 6ds by dragging to nil

rootjoint.Parent = nil
lefthip.Parent = nil
righthip.Parent = nil
leftshoulder.Parent = nil
rightshoulder.Parent = nil
neck.Parent = nil

-- end

-- fake joints

RHipWeld = Instance.new("Weld",torso)
LHipWeld = Instance.new("Weld",torso) 
LShoulderWeld = Instance.new("Weld",torso)
RShoulderWeld = Instance.new("Weld",torso)
NeckWeld = Instance.new("Weld",torso)
TorsoWeld = Instance.new("Weld",rootpart)

-- end

-- change appearance


for i,v in pairs(chara:GetChildren()) do
	if v:IsA("Shirt") then
		v:Destroy()
	end
end

for i,v in pairs(chara:GetChildren()) do
	if v:IsA("ShirtGraphic") then
		v:Destroy()
	end
end

for i,v in pairs(chara:GetChildren()) do
	if v:IsA("Pants") then
		v:Destroy()
	end
end

for i,v in pairs(head:GetChildren()) do
	if v:IsA("SpecialMesh") then
		v:Destroy()
	end
end

for i,v in pairs(chara:GetChildren()) do
	if v:IsA("Accessory") then
		v:Destroy()
	end
end

for i,v in pairs(torso:GetChildren()) do
	if v:IsA("Decal") then
		v:Destroy()
	end
end

for i,v in pairs(chara:GetChildren()) do
	if v:IsA("CharacterMesh") then
		v:Destroy()
	end
end

setting = Instance.new("Folder",chara)
setting.Name = "Settings"
stringval = Instance.new("StringValue",setting)
stringval.Name = "Team"
stringval.Value = "Dummy"
colorbody = chara:FindFirstChildOfClass("BodyColors")
colorbody.HeadColor = BrickColor.new("Medium stone grey")
colorbody.TorsoColor = BrickColor.new("Medium stone grey")
colorbody.LeftArmColor = BrickColor.new("Medium stone grey")
colorbody.RightArmColor = BrickColor.new("Medium stone grey")
colorbody.LeftLegColor = BrickColor.new("Medium stone grey")
colorbody.RightLegColor = BrickColor.new("Medium stone grey")
head.face.Texture = "rbxasset://textures/face.png"

tacticalpart = Instance.new("Part",chara)
tacticalpart.Name = "TacticalVest"
tacticalpart.Size = Vector3.new(2, 2, 1)
tacticalpart.CanCollide = false

vestmesh = Instance.new("SpecialMesh",tacticalpart)
vestmesh.MeshId = "rbxassetid://10293292248"
vestmesh.TextureId = "rbxassetid://6275736670"

vestweld = Instance.new("Weld",tacticalpart)
vestweld.Part0 = tacticalpart
vestweld.Part1 = torso
vestweld.C0 = CFrame.new(0, -0.193, 0.382)*CFrame.fromOrientation(0,math.rad(-180),0)
vestweld.C1 = CFrame.new(0, 0, -0.5)

headmesh = Instance.new("SpecialMesh",head)
headmesh.MeshType = "Head"
headmesh.Scale = Vector3.new(1.25, 1.25, 1.25)
headmesh.Name = "Mesh"

backpack = Instance.new("Part",chara)
backpack.Name = "TacticalBackpack"
backpack.Size = Vector3.new(2, 2, 1)
backpack.CanCollide = false

backpackmesh = Instance.new("SpecialMesh",backpack)
backpackmesh.MeshId = "rbxassetid://4258704356"
backpackmesh.TextureId = "rbxassetid://4239601912"

backpackweld = Instance.new("Weld",backpack)
backpackweld.Part0 = backpack
backpackweld.Part1 = torso
backpackweld.C0 = CFrame.new(-0, -0.017, 0.522)*CFrame.fromOrientation(0,math.rad(-180),0)
backpackweld.C1 = CFrame.new(0, 0, 0.5)

remotepart = Instance.new("Part",chara)
remotepart.Name = "Remote"
remotepart.Size = Vector3.new(1, 1, 1)
remotepart.CanCollide = false

remotemesh = Instance.new("SpecialMesh",remotepart)
remotemesh.MeshId = "rbxassetid://28511792"
remotemesh.TextureId = "rbxassetid://28511890"
remotemesh.Scale = Vector3.new(3,3,3)

remoteweld = Instance.new("Weld",remotepart)
remoteweld.Part0 = remotepart
remoteweld.Part1 = rightarm
remoteweld.C0 = CFrame.new(1, 0.5, 0)*CFrame.fromOrientation(math.rad(90),math.rad(90),math.rad(0))
remoteweld.C1 = CFrame.new(0,0,0)
-- welding proccess

NeckWeld.Name = "Neck"
NeckWeld.Part0 = torso
NeckWeld.Part1 = head
NeckWeld.C0 = CFrame.new(0, 1, 0)--*CFrame.fromOrientation(-90,-180,0)
NeckWeld.C1 = CFrame.new(0,-0.5,0)--*CFrame.fromOrientation(-90,-180,0)

TorsoWeld.Name = "Root Joint"
TorsoWeld.Part0 = torso
TorsoWeld.Part1 = rootpart
TorsoWeld.C0 = CFrame.new(0, 0, 0)--*CFrame.fromOrientation(-90,-180,0)
TorsoWeld.C1 = CFrame.new(0, 0, 0)--*CFrame.fromOrientation(-90,-180,0)

RShoulderWeld.Name = "Right Shoulder"
RShoulderWeld.Part0 = torso
RShoulderWeld.Part1 = rightarm
RShoulderWeld.C0 = CFrame.new(1, 0.5, 0)--*CFrame.fromOrientation(0,90,0)
RShoulderWeld.C1 = CFrame.new(-0.5, 0.5, 0)--*CFrame.fromOrientation(0,90,0)
RShoulderWeld.Parent = torso

LShoulderWeld.Name = "Left Shoulder"
LShoulderWeld.Part0 = torso
LShoulderWeld.Part1 = leftarm
LShoulderWeld.C0 = CFrame.new(-1, 0.5, 0)--*CFrame.fromOrientation(0,-90,0)
LShoulderWeld.C1 = CFrame.new(0.5, 0.5, 0)--*CFrame.fromOrientation(0,-90,0)
LShoulderWeld.Parent = torso

LHipWeld.Name = "Left Hip"
LHipWeld.Part0 = torso
LHipWeld.Part1 = leftleg
LHipWeld.C0 = CFrame.new(-1, -1, 0)--*CFrame.fromOrientation(0,-90,0)
LHipWeld.C1 = CFrame.new(-0.5, 1, 0)--*CFrame.fromOrientation(0,-90,0)
LHipWeld.Parent = torso

RHipWeld.Name = "Right Hip"
RHipWeld.Part0 = torso
RHipWeld.Part1 = rightleg
RHipWeld.C0 = CFrame.new(1, -1, 0)--*CFrame.fromOrientation(0,90,0)
RHipWeld.C1 = CFrame.new(0.5, 1, 0)--*CFrame.fromOrientation(0,90,0)
RHipWeld.Parent = torso

-- end


-- adding anim functions
function makeShockwave(height,color,speed,range,pulse,position)
	local range = range or 2000
	local p = Instance.new("Part")
	p.Name = "ShockWave"
	p.Anchored = true
	p.CanCollide = false
	p.FormFactor = "Custom"
	p.Material = Enum.Material.SmoothPlastic
	p.BrickColor = color
	p.Parent = workspace
	local m = Instance.new("SpecialMesh",p)
	m.MeshId = "rbxassetid://3270017"
	local estimateSurvival = math.floor(range/speed) * 0.03
	game:GetService("Debris"):AddItem(p,estimateSurvival)
	spawn(function ()
		for i = 1,range,speed do
			p.Transparency = 1-math.min(0.5,3-(i/500))
			m.Scale = Vector3.new(i*1,i*1,i*height)
			p.CFrame = CFrame.new(position) * CFrame.Angles(math.rad(90),0,0)
			wait()
		end
		p:Destroy()
	end)
end

function makeBallWave(height,color,speed,range,pulse,position)
	local range = range or 2000
	local p = Instance.new("Part")
	p.Name = "ShockBall"
	p.Anchored = true
	p.CanCollide = false
	p.FormFactor = "Custom"
	p.Size = Vector3.new(1,1,1)
	p.Material = Enum.Material.SmoothPlastic
	p.BrickColor = color
	p.Parent = workspace
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"
	local estimateSurvival = math.floor(range/speed) * 0.03
	game:GetService("Debris"):AddItem(p,estimateSurvival)
	p.Touched:Connect(function(Hit)
		if Hit and Hit.Parent:FindFirstChild("Humanoid") then
			Hit.Parent.Humanoid.Health = 0
		end
	end)
	spawn(function ()
		for i = 1,range,speed do
			p.Transparency = 1-math.min(0.5,3-(i/500))
			m.Scale = Vector3.new(i*height,i*height,i*height)
			p.CFrame = CFrame.new(position) * CFrame.Angles(math.rad(90),0,0)
			wait()
		end
		p:Destroy()
	end)
end

function Detonate()
	attack = true
	cooldown = true
	humanoid.WalkSpeed = 0
	for i = 1,20 do
		swait()
	NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

	TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

	LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

	RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(0, 0, 0),.3)
		
		RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(1.9, 0, 0),.3)

	LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(0, 0, 0),.3)
	end
	for i = 1,20 do
		swait()
		NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

		TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

		LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

		RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

		RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(1.4, 0, 0),.3)

		LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(0, 0, 0),.3)
	end
	wait(1)
	local sound = Instance.new("Sound",workspace)
	sound.SoundId = "rbxassetid://165969964"
	sound.Volume = 10
	sound:Play()
	local sound2 = Instance.new("Sound",workspace)
	sound2.SoundId = "rbxassetid://247893371"
	sound2.Volume = 10
	sound2:Play()
	makeShockwave(0.5,BrickColor.new("Institutional white"),30,1000,0,rootpart.Position)
	makeBallWave(0.5,BrickColor.new("Deep orange"),30,1000,0,rootpart.Position)
	magnidamage(rootpart,150,10000)
	sound.Ended:Connect(function()
		sound:Destroy()
	end)
	sound2.Ended:Connect(function()
		sound2:Destroy()
	end)
end

humanoid.Died:connect(function()
	if attack == false then
	local sound = Instance.new("Sound",chara)
	sound.SoundId = "rbxassetid://165969964"
	sound.Volume = 10
	sound:Play()
	local sound2 = Instance.new("Sound",chara)
	sound2.SoundId = "rbxassetid://247893371"
	sound2.Volume = 10
	sound2:Play()
	sound.Ended:Connect(function()
		sound:Destroy()
	end)
	sound2.Ended:Connect(function()
		sound2:Destroy()
	end)
	makeShockwave(0.5,BrickColor.new("Institutional white"),30,1000,0,rootpart.Position)
	makeBallWave(0.5,BrickColor.new("Deep orange"),30,1000,0,rootpart.Position)
	magnidamage(rootpart,150,10000)
end
end)	

function magnidamage(parent,range,damage)
	for _,v in pairs(workspace:GetChildren()) do
		local hum = v:FindFirstChild("Humanoid")
		if hum ~= nil then
			local rootpart = v:FindFirstChild("HumanoidRootPart")
			if rootpart ~= nil then
				local targ=rootpart.Position-parent.Position
				local mag=targ.magnitude
				if mag <= range then
					hum.Health = -100000000000000
					for i,prts in pairs(hum.Parent:GetChildren()) do
						if prts:IsA("Part") then
							hum.Health = 0
							humanoid.Health = 0
							local explode = Instance.new("Explosion",prts)
								explode.Position = prts.Position
								explode.BlastRadius = 95
								explode.BlastPressure = 100000
								explode.DestroyJointRadiusPercent = 100
							explode.Visible = false
							local explode2 = Instance.new("Explosion",script.Parent)
							explode2.Position = prts.Position
							explode2.BlastRadius = 50
							explode2.BlastPressure = 80000
							explode2.DestroyJointRadiusPercent = 100
							explode2.Visible = false
							explode2.Hit:Connect(function(Part, Distance)
								Part.Anchored = false
								if Distance <= 1500 then
									Part.Anchored = false
									--if Part.Name == "ShockBall" or Part.Name == "ShockWave" or Part.Name == "Baseplate" then
										--Part.Anchored = true
									--else
										Part.Anchored = false
										Part:BreakJoints()
									--end
									
								end	
							end)
							explode.Hit:Connect(function(Part, Distance)
								
								Part.Anchored = false
								if Distance <= 1500 then
									--if Part.Name == "ShockBall" or Part.Name == "ShockWave" or Part.Name == "Baseplate" then
										Part.Anchored = false
									--else
									Part.Anchored = false
									Part:BreakJoints()
									--end
								end	
							end)
						end
					end
				end
			end
		end
	end	
end

function Idle()
			charge = 3
		NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

		TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

	LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(10)*math.cos(sine/100), 0, 0),.3)

	RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-10)*math.cos(sine/100), 0, 0),.3)
	
		RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(10)*math.cos(sine/100), 0, 0),.3)

		LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(-10)*math.cos(sine/100), 0, 0),.3)
end

function Walking()
	charge = 3
	NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

	TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

	LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(math.rad(-30)*math.cos(sine/10), 0, 0),.3)

	RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(30)*math.cos(sine/10), 0, 0),.3)

	RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(-30)*math.cos(sine/10), 0, 0),.3)

	LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(30)*math.cos(sine/10), 0, 0),.3)
end

function Falling()
	charge = 3
	NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

	TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

	LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

	RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

	RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(178), 0, 0),.3)

	LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(178), 0, 0),.3)
end

function Jumping()
	charge = 3
	NeckWeld.C0 = Lerp(NeckWeld.C0,CFrame.new(0, 1, 0) * CFrame.Angles(0, 0, 0),.3)

	TorsoWeld.C0 = Lerp(TorsoWeld.C0,CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),.3)

	LHipWeld.C0 = Lerp(LHipWeld.C0,CFrame.new(-1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

	RHipWeld.C0 = Lerp(RHipWeld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(0, 0, 0),.3)

	RShoulderWeld.C0 = Lerp(RShoulderWeld.C0, CFrame.new(1, 0.5, 0) * CFrame.Angles(math.rad(178), 0, 0),.3)

	LShoulderWeld.C0 = Lerp(LShoulderWeld.C0, CFrame.new(-1, 0.5, 0) * CFrame.Angles(math.rad(178), 0, 0),.3)
end

-- adding lerps

function fakelerp(a, b, t) -- Linear interpolation
	return a + (b - a)*t
end

function slerp(a, b, t) --Spherical interpolation
	local dot = a:Dot(b)
	if dot > 0.99999 or dot < -0.99999 then
		return t <= 0.5 and a or b
	else
		local r = math.acos(dot)
		return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
	end
end

function matrixInterpolate(a, b, t)
	local ax, ay, az, a00, a01, a02, a10, a11, a12, a20, a21, a22 = a:components()
	local bx, by, bz, b00, b01, b02, b10, b11, b12, b20, b21, b22 = b:components()
	local v0 = fakelerp(Vector3.new(ax, ay, az), Vector3.new(bx , by , bz), t) -- Position
	local v1 = slerp(Vector3.new(a00, a01, a02), Vector3.new(b00, b01, b02), t) -- Vector  right
	local v2 = slerp(Vector3.new(a10, a11, a12), Vector3.new(b10, b11, b12), t) -- Vector  up
	local v3 = slerp(Vector3.new(a20, a21, a22), Vector3.new(b20, b21, b22), t) -- Vector  back
	local t = v1:Dot(v2)
	if not (t < 0 or t == 0 or t > 0) then     -- Failsafe
		return CFrame.new()
	end
	return CFrame.new(
		v0.x, v0.y, v0.z,
		v1.x, v1.y, v1.z,
		v2.x, v2.y, v2.z,
		v3.x, v3.y, v3.z)
end

function Lerp(c1,c2,al)
	local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
	local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
	for i,v in pairs(com1) do 
		com1[i] = v+(com2[i]-v)*al
	end
	return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end

function swait(num)
	if num==0 or num==nil then
		game:service'RunService'.Heartbeat:wait(0)
	else
		for i=0,num do
			game:service'RunService'.Heartbeat:wait(0)
		end
	end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end

-- end


-- default anim sets
mse.Button1Down:connect(function()
	if cooldown == false then
		Detonate()
	end
end)

while true do
	swait()
	--humanoid.BreakJointsOnDeath = false
	sine = sine + charge
	local torvel=(rootpart.Velocity*Vector3.new(1,0,1)).magnitude
	local velderp=rootpart.Velocity.y
	hitfloor,posfloor=rayCast(rootpart.Position,(CFrame.new(rootpart.Position,rootpart.Position - Vector3.new(0,1,0))).lookVector,4,chara)
	if equipped==true or equipped==false then
		if attack==false then
			idle=idle+1
		else
			idle=0
		end
		if idle>=500 then
			if attack==false then
			end
		end
		if rootpart.Velocity.y > 1 and hitfloor==nil then
			Anim="Jump"			
			if attack==false then
				Jumping()
			end
		elseif rootpart.Velocity.y < -1 and hitfloor==nil then
			Anim="Fall"		
			if attack==false then
				Falling()
			end
		elseif torvel<1 and hitfloor~=nil then
			Anim="Idle"	
			if attack==false then
				Idle()
			end
		elseif torvel>2 and hitfloor~=nil then
			Anim="Walk"
			if attack==false then
				Walking()
			end
		end
	end
end
